x<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer Sentence Countdown - Extended Voice Fallbacks</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;900&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #1E3A8A 0%, #3B82F6 50%, #93C5FD 100%);
            color: #ffffff;
            overscroll-behavior: none; 
            display: flex; 
            flex-direction: column; 
            min-height: 100vh; 
        }

        .app-container {
            flex-grow: 1; 
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 0.5rem; 
            padding-bottom: 7rem; 
            cursor: pointer;
            position: relative; 
        }

        #countdownDisplay {
            text-shadow: 0 0 10px rgba(0,0,0,0.3), 0 0 20px rgba(0,0,0,0.2);
        }
        
        .custom-focus:focus, .custom-input-focus:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5); 
        }

        .control-button {
            background-color: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 0.5rem; 
            border-radius: 9999px; 
            font-weight: 500;
            transition: background-color 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 2.75rem; 
            height: 2.75rem; 
        }
         .province-button { 
            background-color: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem; 
            font-weight: 500;
            font-size: 0.875rem;
            transition: background-color 0.2s ease;
        }
        .control-button:hover, .province-button:hover {
            background-color: rgba(255, 255, 255, 0.25);
        }
        .control-button:disabled, .province-button:disabled {
            background-color: rgba(255, 255, 255, 0.1);
            color: rgba(255,255,255,0.4); 
            cursor: not-allowed;
        }
        .control-button svg {
            width: 1.25rem; 
            height: 1.25rem; 
        }
        
        .top-bar {
            position: fixed;
            top: 0.5rem;
            left: 0.5rem;
            right: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
            font-size: 0.875rem;
        }

        .bottom-controls {
            position: fixed;
            bottom: 1rem; 
            left: 0.5rem; 
            right: 0.5rem; 
            display: flex;
            justify-content: space-around; 
            align-items: center;
            z-index: 10;
        }
        .settings-grid {
            display: grid;
            grid-template-columns: 1fr; 
            gap: 0.5rem; 
            width: 100%;
            max-width: 20rem; 
            margin-bottom: 1rem; 
        }
        @media (min-width: 640px) { 
            .settings-grid {
                grid-template-columns: 1fr 1fr; 
                 max-width: 28rem;
            }
        }
    </style>
</head>
<body class="antialiased">

    <div class="top-bar">
        <div id="currentPlayerDisplay" class="font-semibold p-2 bg-black/20 rounded-md">Player: Player 1</div>
        <div id="totalGameTimerDisplay" class="font-semibold p-2 bg-black/20 rounded-md">Game: 00:00</div>
    </div>

    <div id="appContainer" class="app-container">
        <div class="settings-grid">
            <div>
                <label for="durationInput" class="block text-sm font-medium mb-1 text-blue-100">Turn Duration (s):</label>
                <input type="number" id="durationInput" value="30" min="1" max="300"
                       inputmode="numeric" pattern="[0-9]*"
                       class="custom-input-focus w-full px-3 py-2 text-center text-md font-semibold bg-white/20 text-white border border-blue-300 rounded-lg shadow-md">
            </div>
            <div>
                <label for="playersInput" class="block text-sm font-medium mb-1 text-blue-100">Players (comma-sep):</label>
                <input type="text" id="playersInput" placeholder="Alice, Bob, ..."
                       class="custom-input-focus w-full px-3 py-2 text-md font-semibold bg-white/20 text-white border border-blue-300 rounded-lg shadow-md">
            </div>
        </div>

        <div id="countdownDisplay" class="text-7xl md:text-8xl font-black my-2"> 
            30 
        </div>

        <div id="statusMessage" class="text-sm text-blue-200 h-5"> 
            Tap anywhere to start or reset
        </div>
    </div>

    <div class="bottom-controls">
        <button id="muteButton" class="control-button" aria-label="Mute or Unmute">
            <svg id="unmutedIcon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" d="M19.114 5.636a9 9 0 0 1 0 12.728M16.463 8.288a5.25 5.25 0 0 1 0 7.424M6.75 8.25l4.72-4.72a.75.75 0 0 1 1.28.53v15.88a.75.75 0 0 1-1.28.53l-4.72-4.72H4.51c-.88 0-1.704-.507-1.938-1.354A9.01 9.01 0 0 1 2.25 12c0-.83.112-1.633.322-2.396C2.806 8.756 3.63 8.25 4.51 8.25H6.75Z" />
            </svg>
            <svg id="mutedIcon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="hidden">
              <path stroke-linecap="round" stroke-linejoin="round" d="M19.114 5.636a9 9 0 0 1 0 12.728M16.463 8.288a5.25 5.25 0 0 1 0 7.424M6.75 8.25l4.72-4.72a.75.75 0 0 1 1.28.53v15.88a.75.75 0 0 1-1.28.53l-4.72-4.72H4.51c-.88 0-1.704-.507-1.938-1.354A9.01 9.01 0 0 1 2.25 12c0-.83.112-1.633.322-2.396C2.806 8.756 3.63 8.25 4.51 8.25H6.75Z" />
              <path stroke-linecap="round" stroke-linejoin="round" d="M4.5 4.5l15 15" />
            </svg>
        </button>
        <button id="provinceButton" class="province-button">Province</button>
        <button id="stopButton" class="control-button" aria-label="Stop Countdown">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" d="M5.25 7.5A2.25 2.25 0 0 1 7.5 5.25h9a2.25 2.25 0 0 1 2.25 2.25v9a2.25 2.25 0 0 1-2.25 2.25h-9a2.25 2.25 0 0 1-2.25-2.25v-9Z" />
            </svg>
        </button>
    </div>

    <script>
        // DOM Elements
        const durationInput = document.getElementById('durationInput');
        const playersInput = document.getElementById('playersInput'); 
        const countdownDisplay = document.getElementById('countdownDisplay');
        const statusMessage = document.getElementById('statusMessage');
        const appContainer = document.getElementById('appContainer');
        const muteButton = document.getElementById('muteButton');
        const provinceButton = document.getElementById('provinceButton'); 
        const stopButton = document.getElementById('stopButton');
        const unmutedIcon = document.getElementById('unmutedIcon');
        const mutedIcon = document.getElementById('mutedIcon');
        const currentPlayerDisplay = document.getElementById('currentPlayerDisplay'); 
        const totalGameTimerDisplay = document.getElementById('totalGameTimerDisplay'); 


        // Speech Synthesis
        const synth = window.speechSynthesis;
        let voices = []; 
        let preferredVoice = null;

        // Countdown State
        let countdownTimerId = null;
        let currentCountdownValue = 0;
        let targetDuration = 30; 
        let isSpeechApiReady = false;
        let isMuted = false;
        let isStopped = true; 

        // Player State
        let players = ["Player 1"]; 
        let currentPlayerIndex = 0;

        // Game Timer State
        let totalGameTimeSeconds = 0;
        let gameTimerId = null;
        let isGameTimerActive = false; 

        const baseSentenceStart = "Hey, your turn is almost up "; 
        const baseSentenceEnd = ", don’t forget to…";
        const endWord = "whoops!";
        
        function findAndSetPreferredVoice() {
            if (!voices || voices.length === 0) {
                console.log("No voices available to set preferred voice.");
                return;
            }

            let foundVoice;

            // 1. Samantha (en-US)
            foundVoice = voices.find(voice => 
                voice.name.toLowerCase().includes('samantha') && voice.lang.toLowerCase() === 'en-us'
            );
            if (foundVoice) {
                preferredVoice = foundVoice;
                console.log("Using preferred voice: Samantha (en-US)");
                return;
            }
            
            // 2. Grandpa (en-US)
            foundVoice = voices.find(voice => 
                voice.name.toLowerCase().includes('grandpa') && voice.lang.toLowerCase() === 'en-us'
            );
             if (foundVoice) {
                preferredVoice = foundVoice;
                console.log("Using fallback voice: Grandpa (en-US)");
                return;
            }

            // 3. Google (en-US, local)
            foundVoice = voices.find(voice => 
                voice.name.toLowerCase().includes('google') && voice.lang.toLowerCase() === 'en-us' && voice.localService
            );
            if (foundVoice) {
                preferredVoice = foundVoice;
                console.log("Using fallback voice (Google US English - Local):", preferredVoice.name);
                return;
            }
            
            // 4. Samsung (en-US, local)
            foundVoice = voices.find(voice => 
                voice.name.toLowerCase().includes('samsung') && voice.lang.toLowerCase() === 'en-us' && voice.localService
            );
            if (foundVoice) {
                preferredVoice = foundVoice;
                console.log("Using fallback voice (Samsung US English - Local):", preferredVoice.name);
                return;
            }
            
            // 5. Any (en-US, local)
            foundVoice = voices.find(voice => voice.lang.toLowerCase() === 'en-us' && voice.localService);
            if (foundVoice) {
                preferredVoice = foundVoice;
                console.log("Using fallback voice (Any Local US English):", preferredVoice.name);
                return;
            }

            // 6. Google (en-US, any)
            foundVoice = voices.find(voice => 
                voice.name.toLowerCase().includes('google') && voice.lang.toLowerCase() === 'en-us'
            );
            if (foundVoice) {
                preferredVoice = foundVoice;
                console.log("Using fallback voice (Google US English - Any):", preferredVoice.name);
                return;
            }

            // 7. Samsung (en-US, any)
            foundVoice = voices.find(voice => 
                voice.name.toLowerCase().includes('samsung') && voice.lang.toLowerCase() === 'en-us'
            );
            if (foundVoice) {
                preferredVoice = foundVoice;
                console.log("Using fallback voice (Samsung US English - Any):", preferredVoice.name);
                return;
            }
            
            // 8. Any (en-US, any)
            foundVoice = voices.find(voice => voice.lang.toLowerCase() === 'en-us');
            if (foundVoice) {
                preferredVoice = foundVoice;
                console.log("Using fallback voice (Any US English):", preferredVoice.name);
                return;
            }
            
            // 9. Any English voice
            foundVoice = voices.find(voice => voice.lang.toLowerCase().startsWith('en'));
             if (foundVoice) {
                preferredVoice = foundVoice;
                console.log("Using fallback voice (First English):", preferredVoice.name);
                return;
            }

            // 10. First voice in the list
            if (voices.length > 0) {
                preferredVoice = voices[0];
                console.log("Using fallback voice (First available):", preferredVoice.name);
            } else {
                console.log("No voices found at all.");
            }
        }

        function loadVoices() {
            if (!synth) {
                isSpeechApiReady = false; updateStatus("Speech API not supported."); return;
            }
            voices = synth.getVoices(); 
            findAndSetPreferredVoice(); 
            const currentReadyState = voices.length > 0; 
            if (currentReadyState && !isSpeechApiReady) {
                if (isStopped) updateStatus("Ready. Tap to start.");
            } else if (!currentReadyState && isSpeechApiReady) { 
                updateStatus("Speech voices lost.");
            } else if (!currentReadyState && !isSpeechApiReady) { 
                 updateStatus("Loading voices..."); 
            }
            isSpeechApiReady = currentReadyState;
        }

        function speak(text, onEndCallback = null) {
            if (isMuted || !isSpeechApiReady || !synth) { 
                if(onEndCallback) onEndCallback(); return; 
            }
            
            synth.cancel(); 
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.text = text === "" ? "\u200B" : text;

            if (preferredVoice) utterance.voice = preferredVoice;
            utterance.pitch = 1.1; utterance.rate = 0.9; 

            utterance.onend = () => { if (onEndCallback) onEndCallback(); };
            utterance.onerror = (e) => {
                console.error(`Speech error for "${text}":`, e.error);
                if (e.error !== 'canceled') updateStatus("Speech error: " + e.error);
                if (onEndCallback) onEndCallback(); 
            };
            try { synth.speak(utterance); } catch (e) {
                console.error("Error synth.speak():", e); updateStatus("Error trying to speak."); if (onEndCallback) onEndCallback();
            }
        }

        function updateMainDisplay(value) { countdownDisplay.textContent = value; }
        function updateStatus(message) { statusMessage.textContent = message; }

        function parsePlayers() {
            const names = playersInput.value.split(',').map(name => name.trim()).filter(name => name.length > 0);
            if (names.length > 0) {
                players = names;
            } else {
                players = ["Player 1"]; 
            }
            if (isStopped || currentPlayerIndex >= players.length) { 
                 currentPlayerIndex = 0;
            }
            updateCurrentPlayerDisplay();
        }

        function updateCurrentPlayerDisplay() {
            currentPlayerDisplay.textContent = `Player: ${players[currentPlayerIndex]}`;
        }
        
        function nextPlayer() {
            currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
            updateCurrentPlayerDisplay();
        }
        
        function getCurrentPlayerName() {
            return players[currentPlayerIndex] || "Player"; 
        }

        function constructDynamicPhraseWords() {
            const name = getCurrentPlayerName();
            // This array represents words for 10s down to 1s.
            return [ 
                "Hey,", "your", "turn", "is", "almost", "up", name + ",", "don’t", "forget", "to…"
            ]; 
        }


        function stopCountdownActions(resetDisplayToTarget = true, advancePlayerOnNaturalEnd = false) {
            isStopped = true;
            if (countdownTimerId) clearInterval(countdownTimerId);
            countdownTimerId = null;
            if(synth) synth.cancel(); 
            
            if (resetDisplayToTarget) { 
                targetDuration = parseInt(durationInput.value, 10) || 30;
                updateMainDisplay(targetDuration);
                // Game Timer: Stop it, mark as inactive. DO NOT reset seconds here.
                if (gameTimerId) { 
                    clearInterval(gameTimerId);
                    gameTimerId = null; // Allow it to be restarted
                }
                isGameTimerActive = false; 
                updateStatus("Stopped. Tap to start new game."); 
            } else { 
                 updateStatus("Time's up! Next player...");
                 if(advancePlayerOnNaturalEnd) nextPlayer(); 
            }
            stopButton.disabled = true; 
            muteButton.disabled = false; 
        }

        function startOrResetCountdown(isTapToStart = false) {
            if (isTapToStart && !isStopped) { 
                nextPlayer();
            } else if (isStopped) { 
                parsePlayers(); 
                // If game was stopped (isGameTimerActive is false), reset game timer seconds for a new game session
                if (!isGameTimerActive) {
                    totalGameTimeSeconds = 0; 
                }
            }
            
            isStopped = false; 
            stopButton.disabled = false;
            muteButton.disabled = false;

            if (!isGameTimerActive) { // Start game timer only if it's not already active or has been reset
                isGameTimerActive = true; // Mark as active
                startGameTimer(); // This will start from totalGameTimeSeconds (which is 0 if new game)
            }


            if (!isSpeechApiReady && synth) loadVoices(); 

            if (countdownTimerId) clearInterval(countdownTimerId);
            if(synth) synth.cancel(); 

            targetDuration = parseInt(durationInput.value, 10);
            if (isNaN(targetDuration) || targetDuration < 1) targetDuration = 1; 
            if (targetDuration > 300) targetDuration = 300;
            durationInput.value = targetDuration; 

            currentCountdownValue = targetDuration;
            updateMainDisplay(currentCountdownValue);
            updateStatus(`${getCurrentPlayerName()}'s turn...`);
            
            const dynamicPhraseWords = constructDynamicPhraseWords(); // Length 10, indices 0-9

            speak(`${getCurrentPlayerName()}'s turn`, () => {
                if (!isStopped && currentCountdownValue > 0) { 
                    // The phrase words are for 10s down to 1s.
                    // dynamicPhraseWords.length is 10.
                    if (currentCountdownValue <= dynamicPhraseWords.length ) { 
                        const wordIndex = dynamicPhraseWords.length - currentCountdownValue; 
                        if (wordIndex >= 0 && wordIndex < dynamicPhraseWords.length ) { 
                             speak(dynamicPhraseWords[wordIndex]);
                        } else { 
                             speak(""); 
                        }
                    } else { 
                        speak(""); 
                    }
                } else if (!isStopped && currentCountdownValue === 0) { 
                     handleCountdownEnd(); 
                }
            });
            
            if (currentCountdownValue > 0) {
                 countdownTimerId = setInterval(countdownTick, 1000);
            } else if (currentCountdownValue === 0 && !isStopped) { 
                 handleCountdownEnd();
            }
        }
        
        function countdownTick() {
            if (isStopped) { 
                clearInterval(countdownTimerId); 
                return; 
            }
            currentCountdownValue--;
            updateMainDisplay(currentCountdownValue);
            
            const dynamicPhraseWords = constructDynamicPhraseWords(); // Length 10

            // Speak word if currentCountdownValue is between 10 and 1
            if (!isStopped && currentCountdownValue > 0 && currentCountdownValue <= dynamicPhraseWords.length ) {
                const wordIndex = dynamicPhraseWords.length - currentCountdownValue; // Correct index for 10..1 -> 0..9
                 if (wordIndex >= 0 && wordIndex < dynamicPhraseWords.length ) { 
                    speak(dynamicPhraseWords[wordIndex]);
                }
            } else if (currentCountdownValue === 0) {
                handleCountdownEnd();
            }
        }

        function handleCountdownEnd() {
            if (countdownTimerId) clearInterval(countdownTimerId); 
            countdownTimerId = null;
            updateMainDisplay("0"); 
            
            if (!isStopped) { 
                speak(endWord, () => stopCountdownActions(false, true)); 
            } else { 
                stopCountdownActions(false, true); 
            }
        }
        
        function updateMuteButtonIcon() {
            if (isMuted) {
                unmutedIcon.classList.add('hidden');
                mutedIcon.classList.remove('hidden');
            } else {
                unmutedIcon.classList.remove('hidden');
                mutedIcon.classList.add('hidden');
            }
        }

        function formatTime(totalSeconds) {
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        function startGameTimer() {
            if (gameTimerId) clearInterval(gameTimerId); // Clear existing if any (e.g. if called multiple times by mistake)
            // totalGameTimeSeconds should be 0 if it's a new game session.
            totalGameTimerDisplay.textContent = `Game: ${formatTime(totalGameTimeSeconds)}`; 
            gameTimerId = setInterval(() => {
                if (isGameTimerActive) { // Only increment if active
                    totalGameTimeSeconds++;
                    totalGameTimerDisplay.textContent = `Game: ${formatTime(totalGameTimeSeconds)}`;
                } else {
                    clearInterval(gameTimerId); // Stop if no longer active
                    gameTimerId = null;
                }
            }, 1000);
        }

        window.onload = () => {
            targetDuration = parseInt(durationInput.value, 10) || 30;
            updateMainDisplay(targetDuration);
            stopButton.disabled = true; 
            updateMuteButtonIcon(); 
            parsePlayers(); 
            totalGameTimerDisplay.textContent = `Game: ${formatTime(totalGameTimeSeconds)}`; 

            if ('speechSynthesis' in window && synth) {
                synth.onvoiceschanged = () => {
                    loadVoices();
                };
                loadVoices(); 
            } else {
                updateStatus("Speech API not supported."); 
                isSpeechApiReady = false;
            }

            appContainer.addEventListener('click', (event) => {
                const el = event.target;
                const isInteractiveControl = el === durationInput || durationInput.contains(el) ||
                                           el === playersInput || playersInput.contains(el) ||
                                           el === muteButton || muteButton.contains(el) || el.closest('#muteButton') ||
                                           el === provinceButton || provinceButton.contains(el) ||
                                           el === stopButton || stopButton.contains(el) || el.closest('#stopButton');
                if (!isInteractiveControl) {
                    startOrResetCountdown(true); 
                }
            });
            
            durationInput.addEventListener('change', () => {
                let newDur = parseInt(durationInput.value, 10);
                if (isNaN(newDur) || newDur < 1) newDur = 1; 
                if (newDur > 300) newDur = 300;
                durationInput.value = newDur; 
                targetDuration = newDur; 
                updateMainDisplay(targetDuration); 
                updateStatus(`Duration: ${targetDuration}s. Tap for ${getCurrentPlayerName()}.`);
                if (!isStopped) startOrResetCountdown(); 
                else stopCountdownActions(true, false); 
            });

            playersInput.addEventListener('input', parsePlayers); 

            muteButton.addEventListener('click', () => {
                isMuted = !isMuted;
                updateMuteButtonIcon();
                if (isMuted && synth && synth.speaking) synth.cancel();
                updateStatus(isMuted ? "Muted" : "Unmuted");
            });

            provinceButton.addEventListener('click', () => {
                speak("Bong");
            });

            stopButton.addEventListener('click', () => {
                stopCountdownActions(true, false); 
            });
        };
    </script>
</body>
</html>